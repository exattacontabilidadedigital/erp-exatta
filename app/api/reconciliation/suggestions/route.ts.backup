import { createClient } from '@supabase/supabase-js';
import { NextRequest, NextResponse } from 'next/server';
import { MatchingEngine, MatchingRule } from '@/lib/matching-engine';

//    // Criar resultados para TODAS as transa√ß√µes banc√°rias, preservando status existentes
    console.log('üîÑ Criando resultados completos preservando status existentes...');
    const allResults = bankTransactions?.map((bankTransaction: any) => {gras padr√£o para quando n√£o h√° regras configuradas no banco
function getDefaultMatchingRules(): MatchingRule[] {
  return [
    {
      id: 'default-valor-data',
      nome: 'Valor e Data com Toler√¢ncia',
      tipo: 'valor_data',
      parametros: {
        tolerancia_valor: 2, // 2% de toler√¢ncia no valor
        tolerancia_dias: 3   // 3 dias de toler√¢ncia na data
      },
      peso: 8,
      ativa: true
    },
    {
      id: 'default-descricao',
      nome: 'Similaridade de Descri√ß√£o',
      tipo: 'descricao',
      parametros: {
        similaridade_minima: 75 // 75% de similaridade m√≠nima
      },
      peso: 7,
      ativa: true
    }
  ];
}

const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
);

export async function GET(request: NextRequest) {
  try {
    console.log('üöÄ GET /api/reconciliation/suggestions iniciado');
    
    const { searchParams } = new URL(request.url);
    const bankAccountId = searchParams.get('bank_account_id');
    const periodStart = searchParams.get('period_start');
    const periodEnd = searchParams.get('period_end');
    const empresaId = searchParams.get('empresa_id');

    if (!bankAccountId || !periodStart || !periodEnd || !empresaId) {
      return NextResponse.json(
        { error: 'Par√¢metros obrigat√≥rios n√£o fornecidos' },
        { status: 400 }
      );
    }

    console.log('üìä Par√¢metros:', { bankAccountId, periodStart, periodEnd, empresaId });

    // Buscar todas as transa√ß√µes banc√°rias do per√≠odo (incluindo j√° conciliadas)
    console.log('üîç Buscando transa√ß√µes banc√°rias...');
    const { data: bankTransactions, error: bankError } = await supabase
      .from('bank_transactions')
      .select('*')
      .eq('bank_account_id', bankAccountId)
      .eq('empresa_id', empresaId)
      .in('reconciliation_status', ['pending', 'reconciled', 'no_match'])
      .gte('posted_at', periodStart)
      .lte('posted_at', periodEnd)
      .order('posted_at', { ascending: false });

    if (bankError) {
      console.error('‚ùå Erro ao buscar transa√ß√µes banc√°rias:', bankError);
      return NextResponse.json(
        { error: 'Erro ao buscar transa√ß√µes banc√°rias' },
        { status: 500 }
      );
    }

    console.log(`‚úÖ Transa√ß√µes banc√°rias encontradas: ${bankTransactions?.length || 0}`);

    // Buscar lan√ßamentos do sistema n√£o conciliados
    console.log('üîç Buscando lan√ßamentos do sistema...');
    const { data: systemTransactions, error: systemError } = await supabase
      .from('lancamentos')
      .select(`
        *,
        plano_contas:plano_conta_id(nome),
        centro_custos:centro_custo_id(nome),
        conta_bancaria:conta_bancaria_id(
          id,
          agencia,
          conta,
          digito,
          banco_id,
          saldo_atual
        )
      `)
      .eq('empresa_id', empresaId)
      .eq('status', 'pago')
      .gte('data_lancamento', periodStart)
      .lte('data_lancamento', periodEnd)
      .order('data_lancamento', { ascending: false });

    if (systemError) {
      console.error('‚ùå Erro ao buscar lan√ßamentos:', systemError);
      return NextResponse.json(
        { error: 'Erro ao buscar lan√ßamentos do sistema' },
        { status: 500 }
      );
    }

    console.log(`‚úÖ Lan√ßamentos do sistema encontrados: ${systemTransactions?.length || 0}`);

    console.log(`üìà Transa√ß√µes banc√°rias: ${bankTransactions?.length || 0}`);
    console.log(`üìà Lan√ßamentos do sistema: ${systemTransactions?.length || 0}`);

    // Buscar matches existentes para considerar no status
    console.log('üîç Verificando matches existentes...');
    const { data: existingMatches, error: matchesError } = await supabase
      .from('transaction_matches')
      .select('*')
      .in('bank_transaction_id', bankTransactions?.map(bt => bt.id) || []);

    if (matchesError) {
      console.error('‚ùå Erro ao buscar matches existentes:', matchesError);
    } else {
      console.log(`üìã Matches existentes encontrados: ${existingMatches?.length || 0}`);
    }

    // Criar um mapa de matches existentes para lookup r√°pido
    const existingMatchesMap = new Map();
    existingMatches?.forEach(match => {
      existingMatchesMap.set(match.bank_transaction_id, match);
    });

    // Buscar regras de matching (ou usar regras padr√£o)
    let matchingRules = [];
    try {
      const { data: rules, error: rulesError } = await supabase
        .from('matching_rules')
        .select('*')
        .eq('empresa_id', empresaId)
        .eq('is_active', true)
        .order('priority', { ascending: false });

      if (rulesError) {
        console.log('‚ö†Ô∏è Tabela matching_rules n√£o existe ainda:', rulesError.message);
        matchingRules = getDefaultMatchingRules();
      } else {
        matchingRules = rules && rules.length > 0 ? rules : getDefaultMatchingRules();
      }
    } catch (error) {
      console.log('‚ö†Ô∏è Erro ao buscar regras de matching (usando regras padr√£o):', error);
      matchingRules = getDefaultMatchingRules();
    }

    console.log(`üéØ Regras de matching aplicadas: ${matchingRules.length}`);
    matchingRules.forEach((rule: MatchingRule) => {
      console.log(`   - ${rule.nome} (${rule.tipo}) - Peso: ${rule.peso}`);
    });

    // Executar algoritmo de matching APENAS para transa√ß√µes realmente pendentes
    console.log('üîç Preparando dados para processamento...');
    
    // Separar transa√ß√µes que j√° t√™m status definido das que precisam de matching
    const transactionsNeedingMatching = bankTransactions?.filter((bt: any) => 
      bt.reconciliation_status === 'pending' && !existingMatchesMap.has(bt.id)
    ) || [];
    
    console.log('üìä An√°lise de transa√ß√µes:', {
      totalBankTransactions: bankTransactions?.length || 0,
      transactionsNeedingMatching: transactionsNeedingMatching.length,
      existingMatches: existingMatches?.length || 0
    });

    let matchResults: any[] = [];

    // Processar matching apenas para transa√ß√µes pendentes sem matches
    if (transactionsNeedingMatching.length > 0) {
      console.log('üéØ Executando matching para transa√ß√µes pendentes...');
      const matchingEngine = new MatchingEngine(matchingRules || []);
      
      const pendingMatchResults = await matchingEngine.processMatching(
        transactionsNeedingMatching,
        systemTransactions || []
      );
      
      console.log(`‚úÖ Matching conclu√≠do para ${pendingMatchResults.length} transa√ß√µes pendentes`);
      matchResults.push(...pendingMatchResults);
    }

    // Criar resultados para TODAS as transa√ß√µes banc√°rias, preservando status existentes
    console.log('ÔøΩ Criando resultados completos preservando status existentes...');
    const allResults = bankTransactions?.map(bankTransaction => {
      // Verificar se esta transa√ß√£o foi processada no matching
      const matchResult = matchResults.find(mr => mr.bankTransaction.id === bankTransaction.id);
      
      if (matchResult) {
        // Usar resultado do matching para transa√ß√µes pendentes
        return matchResult;
      } else {
        // Criar resultado baseado no status atual da transa√ß√£o
        return {
          bankTransaction,
          systemTransaction: null,
          systemTransactions: [],
          status: 'pendente', // Ser√° atualizado na pr√≥xima etapa
          matchScore: 0,
          matchReason: 'Status preservado do banco de dados',
          confidenceLevel: 'baixo',
          matchType: 'preserved'
        };
      }
    }) || [];

    console.log(`‚úÖ Resultados completos criados: ${allResults.length} transa√ß√µes`);

    // Atualizar status baseado em matches existentes e reconciliation_status
    console.log('üîÑ Aplicando status de matches existentes e do banco...');
    allResults.forEach((result: any) => {
      const existingMatch = existingMatchesMap.get(result.bankTransaction.id);
      const bankTransactionStatus = result.bankTransaction.reconciliation_status;
      
      if (existingMatch) {
        console.log(`üìå Match existente encontrado para transa√ß√£o ${result.bankTransaction.id}:`, {
          status: existingMatch.status,
          confidence: existingMatch.confidence_level,
          bankStatus: bankTransactionStatus
        });
        
        // Atualizar status baseado no match existente
        if (existingMatch.status === 'confirmed') {
          result.status = 'conciliado';
        } else if (existingMatch.status === 'rejected') {
          result.status = 'rejeitado';
        } else if (existingMatch.status === 'suggested') {
          result.status = 'sugerido';
        }
        
        // Tamb√©m atualizar outras propriedades relevantes
        result.matchScore = Math.round((existingMatch.match_score || 0) * 100);
        result.confidenceLevel = existingMatch.confidence_level || result.confidenceLevel;
        
        // Se h√° match confirmado, garantir que existe systemTransaction
        if (existingMatch.status === 'confirmed' && existingMatch.system_transaction_id) {
          // Buscar a systemTransaction se n√£o estiver presente
          if (!result.systemTransaction) {
            const systemTxn = systemTransactions?.find((st: any) => st.id === existingMatch.system_transaction_id);
            if (systemTxn) {
              result.systemTransaction = systemTxn;
            }
          }
        }
      } else if (bankTransactionStatus === 'reconciled') {
        // Se n√£o h√° match mas o status √© reconciled, marcar como conciliado
        console.log(`üìå Transa√ß√£o banc√°ria j√° marcada como reconciled: ${result.bankTransaction.id}`);
        result.status = 'conciliado';
        result.matchScore = 100;
        result.confidenceLevel = '100%';
        
        // Se h√° matched_lancamento_id, buscar o lan√ßamento correspondente
        if (result.bankTransaction.matched_lancamento_id) {
          const systemTxn = systemTransactions?.find((st: any) => st.id === result.bankTransaction.matched_lancamento_id);
          if (systemTxn) {
            result.systemTransaction = systemTxn;
            console.log(`üîó Lan√ßamento correspondente encontrado para transa√ß√£o reconciled: ${systemTxn.id}`);
          }
        }
      } else if (bankTransactionStatus === 'no_match') {
        // Se marcada como sem correspond√™ncia
        console.log(`üìå Transa√ß√£o banc√°ria marcada como sem correspond√™ncia: ${result.bankTransaction.id}`);
        result.status = 'sem_match';
        result.matchScore = 0;
        result.confidenceLevel = 'baixo';
      } else {
        // Se n√£o h√° match existente, verificar se √© uma transfer√™ncia desconciliada
        const isTransfer = result.bankTransaction?.memo?.toUpperCase().includes('TRANSFER') || 
                          result.bankTransaction?.payee?.toUpperCase().includes('TRANSFER') ||
                          result.bankTransaction?.transaction_type === 'TRANSFER';
        
        if (isTransfer && result.bankTransaction?.reconciliation_status === 'pending') {
          console.log(`üîÑ Transfer√™ncia desconciliada detectada para transa√ß√£o ${result.bankTransaction.id}`);
          result.status = 'transferencia';
        }
      }
    });

    console.log('‚úÖ Status atualizado baseado em matches existentes');

    // Gerar resumo
    const summary = matchingEngine.generateSummary(matchResults);
    console.log('üìä Summary gerado:', summary);

    // Buscar um usu√°rio para usar como created_by
    const { data: usuarios } = await supabase
      .from('usuarios')
      .select('id')
      .limit(1);
    
    const userId = usuarios?.[0]?.id || null;

    // Criar ou buscar sess√£o de concilia√ß√£o
    let reconciliationSession;
    const { data: existingSession } = await supabase
      .from('reconciliation_sessions')
      .select('*')
      .eq('bank_account_id', bankAccountId)
      .eq('empresa_id', empresaId)
      .eq('period_start', periodStart)
      .eq('period_end', periodEnd)
      .eq('status', 'active')
      .single();

    if (existingSession) {
      reconciliationSession = existingSession;
    } else {
      const { data: newSession, error: sessionError } = await supabase
        .from('reconciliation_sessions')
        .insert({
          bank_account_id: bankAccountId,
          empresa_id: empresaId,
          period_start: periodStart,
          period_end: periodEnd,
          total_bank_transactions: bankTransactions?.length || 0,
          total_system_transactions: systemTransactions?.length || 0,
          matched_transactions: summary.conciliados,
          pending_transactions: summary.sem_match,
          ignored_transactions: 0,
          bank_total_debits: 0.00,
          bank_total_credits: 0.00,
          system_total_debits: 0.00,
          system_total_credits: 0.00,
          difference_amount: 0.00,
          status: 'active',
          auto_match_enabled: true,
          confidence_threshold: 0.80,
          created_by: userId
        })
        .select()
        .single();

      if (sessionError) {
        console.error('‚ùå Erro ao criar sess√£o de concilia√ß√£o:', sessionError);
      } else {
        reconciliationSession = newSession;
      }
    }

    // Salvar matches no banco de dados (apenas os que t√™m system_transaction_id)
    if (reconciliationSession) {
      const matchesToInsert = matchResults
        .filter(result => result.systemTransaction?.id) // Filtrar apenas matches com system_transaction_id
        .map(result => {
          // Usar l√≥gica baseada na estrutura da tabela:
          // - 'confirmed' para matches exatos com alta confian√ßa
          // - 'suggested' para outros matches autom√°ticos
          const dbStatus = (result.confidenceLevel === 'high' && result.matchScore >= 95) 
            ? 'confirmed' 
            : 'suggested';

          return {
            reconciliation_id: reconciliationSession.id,
            bank_transaction_id: result.bankTransaction.id,
            system_transaction_id: result.systemTransaction!.id, // Garantido que existe pelo filter
            match_score: result.matchScore / 100, // Converter de 0-100 para 0.00-1.00
            match_type: result.matchType === 'manual' ? 'manual' : 'automatic',
            confidence_level: result.confidenceLevel,
            status: dbStatus,
            notes: result.matchReason
          };
        });

      console.log(`üíæ Salvando ${matchesToInsert.length} matches v√°lidos (de ${matchResults.length} totais)`);

      if (matchesToInsert.length > 0) {
        const { error: matchesError } = await supabase
          .from('transaction_matches')
          .upsert(matchesToInsert, { 
            onConflict: 'bank_transaction_id,system_transaction_id' 
          });

        if (matchesError) {
          console.error('‚ùå Erro ao salvar matches:', matchesError);
        } else {
          console.log('‚úÖ Matches salvos com sucesso');
        }
      } else {
        console.log('‚ÑπÔ∏è Nenhum match v√°lido para salvar');
      }
    }

    console.log('‚úÖ Sugest√µes geradas com sucesso');

    // Converter matchResults para o formato esperado pelo frontend (pairs)
    const formattedPairs = matchResults.map(result => {
      return {
        id: result.bankTransaction.id,
        bankTransaction: result.bankTransaction,
        systemTransaction: result.systemTransaction || null,
        systemTransactions: result.systemTransactions || [],
        status: result.status,
        matchScore: result.matchScore,
        matchReason: result.matchReason,
        confidenceLevel: result.confidenceLevel,
        matchType: result.matchType
      };
    });

    console.log('üîÑ Dados formatados para frontend:', {
      originalResultsCount: matchResults.length,
      formattedPairsCount: formattedPairs.length,
      sampleFormatted: formattedPairs[0]
    });

    return NextResponse.json({
      success: true,
      reconciliation_id: reconciliationSession?.id,
      pairs: formattedPairs,
      summary,
      bank_transactions: bankTransactions || [],
      system_transactions: systemTransactions || []
    });

  } catch (error) {
    console.error('‚ùå Erro ao gerar sugest√µes:', error);
    console.error('‚ùå Stack trace:', error instanceof Error ? error.stack : 'No stack trace');
    return NextResponse.json(
      { error: 'Erro interno do servidor', details: error instanceof Error ? error.message : 'Erro desconhecido' },
      { status: 500 }
    );
  }
}
