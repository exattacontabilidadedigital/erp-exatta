import { createClient } from '@supabase/supabase-js';
import { NextRequest, NextResponse } from 'next/server';
import { FITIDValidator } from '@/lib/fitid-validator';
import { getUserId, getEmpresaIdFromBankTransaction } from '@/lib/auth-utils';

const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
);

export async function POST(request: NextRequest) {
  try {
    const { 
      bank_transaction_id, 
      system_transaction_id, 
      confidence_level, 
      rule_applied 
    } = await request.json();

    console.log('üîó Iniciando processamento de concilia√ß√£o:', {
      bank_transaction_id,
      system_transaction_id,
      confidence_level,
      rule_applied
    });

    // VALIDA√á√ÉO CR√çTICA: Verificar se esta transa√ß√£o banc√°ria espec√≠fica j√° est√° conciliada
    const { data: existingBankTrans, error: bankCheckError } = await supabase
      .from('bank_transactions')
      .select('id, fit_id, status_conciliacao, reconciliation_status, matched_lancamento_id, memo, payee, amount, posted_at')
      .eq('id', bank_transaction_id)
      .single();

    if (bankCheckError) {
      console.error('‚ùå Erro ao verificar transa√ß√£o banc√°ria:', bankCheckError);
      return NextResponse.json(
        { error: 'Transa√ß√£o banc√°ria n√£o encontrada' },
        { status: 404 }
      );
    }

    console.log('üîç Transa√ß√£o banc√°ria encontrada:', {
      id: existingBankTrans.id,
      fit_id: existingBankTrans.fit_id || 'N/A',
      status: existingBankTrans.status_conciliacao,
      amount: existingBankTrans.amount,
      description: existingBankTrans.memo || existingBankTrans.payee || 'N/A'
    });

    // VALIDA√á√ÉO FITID AVAN√áADA: Usar validador especializado
    console.log('üîí Executando valida√ß√£o FITID...');
    const fitidValidation = await FITIDValidator.validateForConciliation(bank_transaction_id, supabase);
    
    if (!fitidValidation.isValid) {
      console.error('‚ùå Valida√ß√£o FITID falhou:', fitidValidation.error);
      return NextResponse.json({
        success: false,
        message: fitidValidation.error || 'Erro na valida√ß√£o FITID',
        fit_id: fitidValidation.fitId,
        conflicting_transactions: fitidValidation.conflictingTransactions
      }, { status: 409 });
    }

    console.log('‚úÖ Valida√ß√£o FITID aprovada:', { fit_id: fitidValidation.fitId });

    // VALIDA√á√ÉO FITID: Verificar se j√° existe outra concilia√ß√£o com o mesmo FITID
    if (existingBankTrans.fit_id) {
      const { data: fitIdConflicts, error: fitIdError } = await supabase
        .from('bank_transactions')
        .select('id, fit_id, status_conciliacao, matched_lancamento_id')
        .eq('fit_id', existingBankTrans.fit_id)
        .eq('status_conciliacao', 'conciliado')
        .neq('id', bank_transaction_id); // Excluir a pr√≥pria transa√ß√£o

      if (fitIdError) {
        console.error('‚ùå Erro ao verificar conflitos de FITID:', fitIdError);
      } else if (fitIdConflicts && fitIdConflicts.length > 0) {
        console.log('‚ö†Ô∏è FITID j√° conciliado em outra transa√ß√£o:', {
          fit_id: existingBankTrans.fit_id,
          current_transaction: bank_transaction_id,
          conflicting_transactions: fitIdConflicts
        });
        
        return NextResponse.json({
          success: false,
          message: `Transa√ß√£o com FITID ${existingBankTrans.fit_id} j√° foi conciliada em outra transa√ß√£o`,
          conflicting_transactions: fitIdConflicts,
          fit_id: existingBankTrans.fit_id
        }, { status: 409 });
      }
    }

    // Se j√° est√° conciliada, impedir nova concilia√ß√£o
    if (existingBankTrans.status_conciliacao === 'conciliado') {
      console.log('‚ö†Ô∏è Transa√ß√£o banc√°ria j√° est√° conciliada:', {
        id: bank_transaction_id,
        fit_id: existingBankTrans.fit_id,
        current_status: existingBankTrans.status_conciliacao,
        matched_to: existingBankTrans.matched_lancamento_id
      });
      
      return NextResponse.json({
        success: false,
        message: 'Esta transa√ß√£o banc√°ria j√° est√° conciliada',
        current_match: existingBankTrans.matched_lancamento_id,
        fit_id: existingBankTrans.fit_id
      }, { status: 409 }); // Conflict
    }

    // Se n√£o h√° system_transaction_id, √© uma transa√ß√£o "sem correspond√™ncia"
    if (!system_transaction_id) {
      console.log('üö´ Marcando transa√ß√£o como sem correspond√™ncia');
      
      const { error: updateError } = await supabase
        .from('bank_transactions')
        .update({ 
          reconciliation_status: 'sem_match',  // Corrigido: classifica√ß√£o de matching
          status_conciliacao: 'ignorado',       // Correto: a√ß√£o do usu√°rio
          matched_lancamento_id: null,
          match_confidence: null
        })
        .eq('id', bank_transaction_id); // √öNICO UPDATE por ID espec√≠fico

      if (updateError) {
        console.error('‚ùå Erro ao atualizar transa√ß√£o banc√°ria:', updateError);
        return NextResponse.json(
          { error: 'Erro ao marcar transa√ß√£o como sem correspond√™ncia' },
          { status: 500 }
        );
      }

      return NextResponse.json({ 
        success: true, 
        message: 'Transa√ß√£o marcada como sem correspond√™ncia' 
      });
    }

    // VALIDA√á√ÉO CR√çTICA: Verificar se o lan√ßamento do sistema existe e n√£o est√° ocupado
    const { data: existingSystemTrans, error: systemCheckError } = await supabase
      .from('lancamentos')
      .select('id, descricao, valor, data_lancamento')
      .eq('id', system_transaction_id)
      .single();

    if (systemCheckError) {
      console.error('‚ùå Erro ao verificar lan√ßamento do sistema:', systemCheckError);
      return NextResponse.json(
        { error: 'Lan√ßamento do sistema n√£o encontrado' },
        { status: 404 }
      );
    }

    // ‚úÖ VALIDA√á√ÉO CR√çTICA MELHORADA: Verificar TODOS os matches para este lan√ßamento
    const { data: existingMatches, error: matchCheckError } = await supabase
      .from('transaction_matches')
      .select('bank_transaction_id, system_transaction_id, status, created_at')
      .eq('system_transaction_id', system_transaction_id);

    if (matchCheckError) {
      console.error('‚ùå Erro ao verificar matches existentes:', matchCheckError);
      return NextResponse.json(
        { error: 'Erro ao verificar lan√ßamentos conciliados' },
        { status: 500 }
      );
    }

    // ‚úÖ REGRA R√çGIDA: Um lan√ßamento do sistema pode ter APENAS UM match confirmado
    const confirmedMatches = existingMatches?.filter(m => m.status === 'confirmed') || [];
    
    if (confirmedMatches.length > 0) {
      // Verificar se √© uma tentativa de re-conciliar a mesma transa√ß√£o (permitido)
      const isSameTransaction = confirmedMatches.some(match => 
        match.bank_transaction_id === bank_transaction_id
      );
      
      if (!isSameTransaction) {
        console.log('üö´ BLOQUEADO: Lan√ßamento do sistema j√° est√° conciliado com outra transa√ß√£o:', {
          system_transaction_id,
          existing_matches: confirmedMatches,
          attempted_bank_transaction_id: bank_transaction_id
        });
        
        return NextResponse.json({
          success: false,
          error: 'DUPLICA√á√ÉO_BLOQUEADA',
          message: 'Este lan√ßamento do sistema j√° est√° conciliado com outra transa√ß√£o banc√°ria',
          system_transaction_id,
          existing_confirmed_matches: confirmedMatches
        }, { status: 409 });
      } else {
        console.log('‚úÖ Re-concilia√ß√£o permitida - mesma transa√ß√£o');
      }
    }

    // ‚úÖ LIMPEZA AUTOM√ÅTICA: Remover matches pendentes ou sugeridos antes de confirmar
    if (existingMatches && existingMatches.length > 0) {
      const pendingMatches = existingMatches.filter(m => 
        m.status !== 'confirmed' && m.bank_transaction_id !== bank_transaction_id
      );
      
      if (pendingMatches.length > 0) {
        console.log('üßπ Limpando matches pendentes/sugeridos:', pendingMatches.length);
        
        const { error: cleanupError } = await supabase
          .from('transaction_matches')
          .delete()
          .in('bank_transaction_id', pendingMatches.map(m => m.bank_transaction_id))
          .eq('system_transaction_id', system_transaction_id)
          .neq('status', 'confirmed');
          
        if (cleanupError) {
          console.error('‚ö†Ô∏è Erro na limpeza de matches pendentes:', cleanupError);
          // N√£o falhar aqui - continuar com a concilia√ß√£o
        }
      }
    }

    // ‚úÖ VALIDA√á√ÉO ADICIONAL: Verificar se a transa√ß√£o banc√°ria tamb√©m n√£o est√° duplicada
    const { data: bankMatches, error: bankMatchError } = await supabase
      .from('transaction_matches')
      .select('bank_transaction_id, system_transaction_id, status, created_at')
      .eq('bank_transaction_id', bank_transaction_id);

    if (bankMatchError) {
      console.error('‚ùå Erro ao verificar matches da transa√ß√£o banc√°ria:', bankMatchError);
      return NextResponse.json(
        { error: 'Erro ao verificar transa√ß√£o banc√°ria' },
        { status: 500 }
      );
    }

    const confirmedBankMatches = bankMatches?.filter(m => m.status === 'confirmed') || [];
    
    if (confirmedBankMatches.length > 0) {
      // Verificar se √© uma tentativa de re-conciliar o mesmo lan√ßamento (permitido)
      const isSameSystemTransaction = confirmedBankMatches.some(match => 
        match.system_transaction_id === system_transaction_id
      );
      
      if (!isSameSystemTransaction) {
        console.log('üö´ BLOQUEADO: Transa√ß√£o banc√°ria j√° est√° conciliada com outro lan√ßamento:', {
          bank_transaction_id,
          existing_matches: confirmedBankMatches,
          attempted_system_transaction_id: system_transaction_id
        });
        
        return NextResponse.json({
          success: false,
          error: 'TRANSACAO_BANCARIA_JA_CONCILIADA',
          message: 'Esta transa√ß√£o banc√°ria j√° est√° conciliada com outro lan√ßamento do sistema',
          bank_transaction_id,
          existing_confirmed_matches: confirmedBankMatches
        }, { status: 409 });
      } else {
        console.log('‚úÖ Re-concilia√ß√£o permitida - mesmo lan√ßamento do sistema');
      }
    }

    // TRANSACTION: Atualizar match espec√≠fico de forma at√¥mica
    console.log('üîÑ Iniciando concilia√ß√£o at√¥mica...');

    // 1. ‚úÖ VERIFICAR SE H√Å M√öLTIPLOS MATCHES EXISTENTES
    console.log('üîç Verificando m√∫ltiplos matches existentes...');
    const { data: allExistingMatches, error: existingError } = await supabase
      .from('transaction_matches')
      .select('*')
      .eq('bank_transaction_id', bank_transaction_id);
    
    const hasMultipleMatches = allExistingMatches && allExistingMatches.length > 1;
    console.log(`üìä Matches existentes: ${allExistingMatches?.length || 0} (m√∫ltiplos: ${hasMultipleMatches})`);

    // 2. ‚úÖ LIMPEZA PREVENTIVA: Modificada para preservar m√∫ltiplos matches
    console.log('üßπ Executando limpeza preventiva de conflitos...');
    
    if (hasMultipleMatches) {
      // Se h√° m√∫ltiplos matches, apenas atualizar todos para 'confirmed' em vez de remover
      console.log('üîÑ Preservando m√∫ltiplos matches - atualizando status para confirmed...');
      const { error: updateError } = await supabase
        .from('transaction_matches')
        .update({ 
          status: 'confirmed',
          updated_at: new Date().toISOString()
        })
        .eq('bank_transaction_id', bank_transaction_id);
        
      if (updateError) {
        console.error('‚ö†Ô∏è Erro ao atualizar m√∫ltiplos matches:', updateError);
      } else {
        console.log('‚úÖ M√∫ltiplos matches preservados e confirmados');
      }
    } else {
      // L√≥gica original para matches simples
      const { error: cleanupBankError } = await supabase
        .from('transaction_matches')
        .delete()
        .eq('bank_transaction_id', bank_transaction_id)
        .neq('status', 'confirmed');
        
      if (cleanupBankError) {
        console.error('‚ö†Ô∏è Erro na limpeza de matches banc√°rios:', cleanupBankError);
      }
    }
    
    // Remover matches pendentes/sugeridos do lan√ßamento do sistema (exceto confirmed)
    const { error: cleanupSystemError } = await supabase
      .from('transaction_matches')
      .delete()
      .eq('system_transaction_id', system_transaction_id)
      .neq('status', 'confirmed')
      .neq('bank_transaction_id', bank_transaction_id); // Manter se for o mesmo par
      
    if (cleanupSystemError) {
      console.error('‚ö†Ô∏è Erro na limpeza de matches do sistema:', cleanupSystemError);
    }

    // 3. Criar/atualizar o match espec√≠fico (APENAS se n√£o h√° m√∫ltiplos matches)
    let matchData = null;
    
    if (!hasMultipleMatches) {
      // L√≥gica original para match simples
      const { data: newMatchData, error: matchError } = await supabase
        .from('transaction_matches')
        .upsert({
          bank_transaction_id,
          system_transaction_id,
          match_score: confidence_level === '100%' ? 1.0 : 
                      confidence_level === 'high' ? 0.9 :
                      confidence_level === 'provavel' ? 0.8 : 
                      confidence_level === 'manual' ? 1.0 : 0.5,
          match_type: confidence_level === 'manual' ? 'manual' : 'automatic',
          confidence_level: 'high',
          status: 'confirmed',
          is_primary: true,
          created_at: new Date().toISOString(),
          updated_at: new Date().toISOString()
        })
        .select()
        .single();

      if (matchError) {
        console.error('‚ùå Erro ao criar/atualizar match:', matchError);
        return NextResponse.json(
          { error: 'Erro ao criar match de concilia√ß√£o', details: matchError.message },
          { status: 500 }
        );
      }
      
      matchData = newMatchData;
      console.log('‚úÖ Match de concilia√ß√£o criado:', matchData.id);
    } else {
      console.log('‚ÑπÔ∏è M√∫ltiplos matches preservados - n√£o criando novo match');
      // Usar o match prim√°rio dos existentes
      matchData = allExistingMatches?.find(m => m.is_primary) || allExistingMatches?.[0];
    }

    if (!matchData) {
      console.error('‚ùå Erro: Nenhum match foi criado ou encontrado');
      return NextResponse.json(
        { error: 'Erro interno: Nenhum match dispon√≠vel' },
        { status: 500 }
      );
    }
      console.error('‚ùå Erro ao criar/atualizar match:', matchError);
      return NextResponse.json(
        { error: 'Erro ao criar concilia√ß√£o espec√≠fica' },
        { status: 500 }
      );
    }

    // 2. Atualizar transa√ß√£o banc√°ria com TODOS os campos de auditoria
    const confidenceValue = confidence_level === '100%' ? 1.0 : 
                            confidence_level === 'high' ? 0.9 :
                            confidence_level === 'provavel' ? 0.8 : 
                            confidence_level === 'manual' ? 1.0 : 0.5;

    // Determinar o tipo de match baseado no rule_applied
    const matchType = rule_applied?.includes('manual') ? 'manual' :
                     rule_applied?.includes('exact') ? 'exact' :
                     rule_applied?.includes('fuzzy') ? 'fuzzy' : 'rule';

    // Obter empresa_id e user_id para auditoria
    const empresaId = await getEmpresaIdFromBankTransaction(bank_transaction_id);
    const userId = await getUserId(request, empresaId || undefined);

    console.log('üîç Dados de auditoria:', {
      empresaId,
      userId: userId || 'N√£o dispon√≠vel',
      source: userId ? 'Obtido dinamicamente' : 'Fallback n√£o encontrado'
    });

    // Criar crit√©rios de match detalhados
    const matchCriteria = {
      rule_applied: rule_applied || 'unknown',
      confidence_level,
      timestamp: new Date().toISOString(),
      system_transaction_id,
      bank_transaction_id,
      match_score: confidenceValue,
      empresa_id: empresaId,
      user_id: userId,
      criteria_used: {
        amount_match: true,
        date_match: true,
        description_match: rule_applied?.includes('description') || false,
        transfer_detection: rule_applied?.includes('transfer') || false,
        manual_override: rule_applied?.includes('manual') || false
      }
    };
    
    const { error: updateError } = await supabase
      .from('bank_transactions')
      .update({ 
        // Status fields - CORRIGIDO conforme especifica√ß√£o
        reconciliation_status: 'sugerido',     // Classifica√ß√£o: sugerido/transferencia/sem_match
        status_conciliacao: 'conciliado',      // A√ß√£o do usu√°rio: pendente/conciliado/etc
        
        // Match fields - IMPLEMENTA√á√ÉO COMPLETA
        matched_lancamento_id: system_transaction_id,
        match_confidence: confidenceValue,
        match_type: matchType,
        match_criteria: matchCriteria,
        
        // Audit fields - IMPLEMENTA√á√ÉO COMPLETA
        reconciled_at: new Date().toISOString(),
        reconciled_by: userId,
        reconciliation_notes: `Conciliado via ${rule_applied || 'sistema'} com confian√ßa ${confidence_level}${userId ? ` por usu√°rio ${userId}` : ''}`,
        
        // Update timestamp
        updated_at: new Date().toISOString()
      })
      .eq('id', bank_transaction_id); // ‚úÖ √öNICO UPDATE por ID espec√≠fico

    if (updateError) {
      console.error('‚ùå Erro ao atualizar transa√ß√£o banc√°ria espec√≠fica:', updateError);
      
      // Reverter o match se falhou o update da transa√ß√£o
      await supabase
        .from('transaction_matches')
        .delete()
        .eq('bank_transaction_id', bank_transaction_id)
        .eq('system_transaction_id', system_transaction_id);
        
      return NextResponse.json(
        { error: 'Erro ao atualizar status da transa√ß√£o banc√°ria' },
        { status: 500 }
      );
    }

    console.log('‚úÖ Concilia√ß√£o completa bem-sucedida:', {
      bank_transaction_id,
      system_transaction_id,
      match_id: matchData.id,
      fit_id: existingBankTrans.fit_id || 'N/A',
      bank_amount: existingBankTrans.amount,
      confidence_level,
      match_type: matchType,
      match_confidence: confidenceValue,
      reconciled_at: new Date().toISOString(),
      match_criteria: matchCriteria
    });

    return NextResponse.json({ 
      success: true, 
      message: 'Concilia√ß√£o completa realizada com sucesso',
      data: {
        match_id: matchData.id,
        bank_transaction_id,
        system_transaction_id,
        match_type: matchType,
        match_confidence: confidenceValue,
        reconciled_at: new Date().toISOString(),
        rule_applied: rule_applied || 'sistema'
      }
    });

  } catch (error) {
    console.error('‚ùå Erro no endpoint de concilia√ß√£o espec√≠fica:', error);
    return NextResponse.json(
      { error: 'Erro interno do servidor', details: error instanceof Error ? error.message : 'Erro desconhecido' },
      { status: 500 }
    );
  }
}
