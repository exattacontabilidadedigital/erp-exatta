import { createClient } from '@supabase/supabase-js';
import { NextRequest, NextResponse } from 'next/server';

const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
);

export async function GET(request: NextRequest) {
  try {
    console.log('üöÄ GET /api/conciliacao/relatorio iniciado');
    
    const { searchParams } = new URL(request.url);
    const bancoId = searchParams.get('bancoId');
    const dataInicio = searchParams.get('dataInicio');
    const dataFim = searchParams.get('dataFim');
    
    console.log('üìä Par√¢metros do relat√≥rio:', { bancoId, dataInicio, dataFim });

    // Base query para transa√ß√µes banc√°rias
    let queryBase = supabase
      .from('transacoes_bancarias')
      .select(`
        *,
        conta_bancaria:conta_bancaria_id(nome, banco),
        lancamento:lancamento_id(
          *,
          plano_contas:plano_conta_id(nome),
          centro_custos:centro_custo_id(nome)
        )
      `);

    if (bancoId) {
      queryBase = queryBase.eq('conta_bancaria_id', bancoId);
    }

    if (dataInicio && dataFim) {
      queryBase = queryBase.gte('data', dataInicio).lte('data', dataFim);
    }

    // 1. Buscar todas as transa√ß√µes
    const { data: todasTransacoes, error: errorTransacoes } = await queryBase
      .order('data', { ascending: false });

    if (errorTransacoes) {
      console.error('‚ùå Erro ao buscar transa√ß√µes:', errorTransacoes);
      return NextResponse.json(
        { error: 'Erro ao buscar transa√ß√µes banc√°rias' },
        { status: 500 }
      );
    }

    console.log(`üìà Total de transa√ß√µes encontradas: ${todasTransacoes?.length || 0}`);

    // 2. Separar transa√ß√µes conciliadas e n√£o conciliadas
    const conciliadas = todasTransacoes?.filter(t => t.lancamento_id) || [];
    const naoConciliadas = todasTransacoes?.filter(t => !t.lancamento_id) || [];

    // 3. Calcular estat√≠sticas
    const estatisticas = {
      total: todasTransacoes?.length || 0,
      conciliadas: conciliadas.length,
      naoConciliadas: naoConciliadas.length,
      percentualConciliacao: todasTransacoes?.length > 0 
        ? ((conciliadas.length / todasTransacoes.length) * 100).toFixed(2)
        : '0.00',
      
      // Valores
      valorTotalCreditos: 0,
      valorTotalDebitos: 0,
      valorConciliadoCreditos: 0,
      valorConciliadoDebitos: 0,
      valorNaoConciliadoCreditos: 0,
      valorNaoConciliadoDebitos: 0,
      
      // Por tipo
      creditosConciliados: 0,
      debitosConciliados: 0,
      creditosNaoConciliados: 0,
      debitosNaoConciliados: 0
    };

    // Calcular valores
    todasTransacoes?.forEach(transacao => {
      const valor = parseFloat(transacao.valor) || 0;
      const isCredito = valor >= 0;
      
      if (isCredito) {
        estatisticas.valorTotalCreditos += valor;
        if (transacao.lancamento_id) {
          estatisticas.valorConciliadoCreditos += valor;
          estatisticas.creditosConciliados++;
        } else {
          estatisticas.valorNaoConciliadoCreditos += valor;
          estatisticas.creditosNaoConciliados++;
        }
      } else {
        estatisticas.valorTotalDebitos += Math.abs(valor);
        if (transacao.lancamento_id) {
          estatisticas.valorConciliadoDebitos += Math.abs(valor);
          estatisticas.debitosConciliados++;
        } else {
          estatisticas.valorNaoConciliadoDebitos += Math.abs(valor);
          estatisticas.debitosNaoConciliados++;
        }
      }
    });

    // 4. Buscar lan√ßamentos n√£o conciliados (para mostrar lan√ßamentos sem transa√ß√£o banc√°ria)
    let queryLancamentos = supabase
      .from('lancamentos')
      .select(`
        *,
        plano_contas:plano_conta_id(nome),
        centro_custos:centro_custo_id(nome)
      `)
      .eq('status', 'pendente');

    if (dataInicio && dataFim) {
      queryLancamentos = queryLancamentos.gte('data_lancamento', dataInicio).lte('data_lancamento', dataFim);
    }

    const { data: lancamentosPendentes, error: errorLancamentos } = await queryLancamentos
      .order('data_lancamento', { ascending: false });

    if (errorLancamentos) {
      console.warn('‚ö†Ô∏è Erro ao buscar lan√ßamentos pendentes:', errorLancamentos);
    }

    // 5. Agrupar por data para an√°lise temporal
    const agrupamentoPorData = {};
    todasTransacoes?.forEach(transacao => {
      const data = transacao.data;
      if (!agrupamentoPorData[data]) {
        agrupamentoPorData[data] = {
          data,
          total: 0,
          conciliadas: 0,
          naoConciliadas: 0,
          valorTotal: 0,
          valorConciliado: 0,
          valorNaoConciliado: 0
        };
      }
      
      const grupo = agrupamentoPorData[data];
      const valor = parseFloat(transacao.valor) || 0;
      
      grupo.total++;
      grupo.valorTotal += Math.abs(valor);
      
      if (transacao.lancamento_id) {
        grupo.conciliadas++;
        grupo.valorConciliado += Math.abs(valor);
      } else {
        grupo.naoConciliadas++;
        grupo.valorNaoConciliado += Math.abs(valor);
      }
    });

    const analiseTemporal = Object.values(agrupamentoPorData)
      .sort((a: any, b: any) => new Date(b.data).getTime() - new Date(a.data).getTime());

    // 6. Principais desconcilia√ß√µes (maiores valores)
    const principaisDesconciliacoes = naoConciliadas
      .sort((a, b) => Math.abs(parseFloat(b.valor)) - Math.abs(parseFloat(a.valor)))
      .slice(0, 10);

    console.log('‚úÖ Relat√≥rio gerado com sucesso');
    console.log('üìä Estat√≠sticas:', {
      total: estatisticas.total,
      conciliadas: estatisticas.conciliadas,
      percentual: estatisticas.percentualConciliacao + '%'
    });

    return NextResponse.json({
      estatisticas,
      conciliadas,
      naoConciliadas,
      lancamentosPendentes: lancamentosPendentes || [],
      analiseTemporal,
      principaisDesconciliacoes,
      metadata: {
        dataGeracao: new Date().toISOString(),
        periodo: dataInicio && dataFim ? { inicio: dataInicio, fim: dataFim } : null,
        banco: bancoId || 'todos'
      }
    });

  } catch (error) {
    console.error('‚ùå Erro interno na API de relat√≥rio:', error);
    return NextResponse.json(
      { error: 'Erro interno do servidor' },
      { status: 500 }
    );
  }
}

export async function POST(request: NextRequest) {
  try {
    console.log('üöÄ POST /api/conciliacao/relatorio - Exporta√ß√£o iniciada');
    
    const { 
      bancoId, 
      dataInicio, 
      dataFim, 
      formato = 'json',
      incluirDetalhes = true 
    } = await request.json();

    console.log('üìä Par√¢metros de exporta√ß√£o:', { bancoId, dataInicio, dataFim, formato, incluirDetalhes });

    // Reutilizar a l√≥gica do GET
    const url = new URL(request.url);
    if (bancoId) url.searchParams.set('bancoId', bancoId);
    if (dataInicio) url.searchParams.set('dataInicio', dataInicio);
    if (dataFim) url.searchParams.set('dataFim', dataFim);

    // Simular GET request
    const mockRequest = new NextRequest(url.toString());
    const response = await exports.GET(mockRequest);
    const dados = await response.json();

    if (!response.ok) {
      return response;
    }

    // Preparar dados para exporta√ß√£o
    let dadosExportacao;

    switch (formato.toLowerCase()) {
      case 'csv':
        dadosExportacao = formatarParaCSV(dados, incluirDetalhes);
        break;
      case 'excel':
        dadosExportacao = formatarParaExcel(dados, incluirDetalhes);
        break;
      default:
        dadosExportacao = dados;
    }

    console.log('‚úÖ Exporta√ß√£o conclu√≠da');

    return NextResponse.json({
      success: true,
      formato,
      dados: dadosExportacao,
      metadata: {
        totalRegistros: dados.estatisticas.total,
        dataExportacao: new Date().toISOString()
      }
    });

  } catch (error) {
    console.error('‚ùå Erro interno na exporta√ß√£o:', error);
    return NextResponse.json(
      { error: 'Erro interno do servidor' },
      { status: 500 }
    );
  }
}

function formatarParaCSV(dados: any, incluirDetalhes: boolean) {
  const linhas = [];
  
  // Cabe√ßalho do resumo
  linhas.push('RELAT√ìRIO DE CONCILIA√á√ÉO BANC√ÅRIA');
  linhas.push('');
  linhas.push(`Data de Gera√ß√£o,${dados.metadata.dataGeracao}`);
  linhas.push(`Total de Transa√ß√µes,${dados.estatisticas.total}`);
  linhas.push(`Conciliadas,${dados.estatisticas.conciliadas}`);
  linhas.push(`N√£o Conciliadas,${dados.estatisticas.naoConciliadas}`);
  linhas.push(`Percentual de Concilia√ß√£o,${dados.estatisticas.percentualConciliacao}%`);
  linhas.push('');

  if (incluirDetalhes) {
    // Transa√ß√µes n√£o conciliadas
    linhas.push('TRANSA√á√ïES N√ÉO CONCILIADAS');
    linhas.push('Data,Descri√ß√£o,Valor,Tipo,Banco');
    
    dados.naoConciliadas.forEach((transacao: any) => {
      const valor = parseFloat(transacao.valor);
      const tipo = valor >= 0 ? 'Cr√©dito' : 'D√©bito';
      linhas.push(`${transacao.data},"${transacao.descricao}",${Math.abs(valor).toFixed(2)},${tipo},"${transacao.conta_bancaria?.nome || 'N/A'}"`);
    });
    
    linhas.push('');
    
    // Lan√ßamentos pendentes
    linhas.push('LAN√áAMENTOS PENDENTES');
    linhas.push('Data,Descri√ß√£o,Valor,Tipo,Plano de Contas');
    
    dados.lancamentosPendentes.forEach((lancamento: any) => {
      linhas.push(`${lancamento.data_lancamento},"${lancamento.descricao}",${Math.abs(parseFloat(lancamento.valor)).toFixed(2)},${lancamento.tipo},"${lancamento.plano_contas?.nome || 'N/A'}"`);
    });
  }

  return linhas.join('\n');
}

function formatarParaExcel(dados: any, incluirDetalhes: boolean) {
  // Retorna estrutura que pode ser usada para gerar Excel no frontend
  return {
    planilhas: [
      {
        nome: 'Resumo',
        dados: [
          ['M√©trica', 'Valor'],
          ['Total de Transa√ß√µes', dados.estatisticas.total],
          ['Conciliadas', dados.estatisticas.conciliadas],
          ['N√£o Conciliadas', dados.estatisticas.naoConciliadas],
          ['Percentual de Concilia√ß√£o', dados.estatisticas.percentualConciliacao + '%'],
          ['Valor Total Cr√©ditos', `R$ ${dados.estatisticas.valorTotalCreditos.toFixed(2)}`],
          ['Valor Total D√©bitos', `R$ ${dados.estatisticas.valorTotalDebitos.toFixed(2)}`]
        ]
      },
      ...(incluirDetalhes ? [
        {
          nome: 'N√£o Conciliadas',
          dados: [
            ['Data', 'Descri√ß√£o', 'Valor', 'Tipo', 'Banco'],
            ...dados.naoConciliadas.map((t: any) => [
              t.data,
              t.descricao,
              Math.abs(parseFloat(t.valor)),
              parseFloat(t.valor) >= 0 ? 'Cr√©dito' : 'D√©bito',
              t.conta_bancaria?.nome || 'N/A'
            ])
          ]
        },
        {
          nome: 'Lan√ßamentos Pendentes',
          dados: [
            ['Data', 'Descri√ß√£o', 'Valor', 'Tipo', 'Plano de Contas'],
            ...dados.lancamentosPendentes.map((l: any) => [
              l.data_lancamento,
              l.descricao,
              Math.abs(parseFloat(l.valor)),
              l.tipo,
              l.plano_contas?.nome || 'N/A'
            ])
          ]
        }
      ] : [])
    ]
  };
}
